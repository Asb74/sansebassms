name: iOS Signed Build & TestFlight

on:
  workflow_dispatch:
  push:
    tags:
      - 'v*.*.*'

jobs:
  ios:
    runs-on: macos-latest
    timeout-minutes: 60

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Flutter
        uses: subosito/flutter-action@v2
        with:
          channel: stable

      - name: Flutter pub get
        run: flutter pub get

      - name: Install CocoaPods
        run: |
          sudo gem install cocoapods -N
          cd ios
          pod install --no-repo-update

      - name: Install fastlane
        run: gem install fastlane -N

      - name: Decode signing assets
        shell: bash
        run: |
          printf "%s" "${{ secrets.P12_BASE64 }}" | base64 --decode > cert.p12
          printf "%s" "${{ secrets.PROVISIONING_PROFILE_BASE64 }}" | base64 --decode > profile.mobileprovision
          printf "%s" "${{ secrets.APP_STORE_CONNECT_API_KEY_BASE64 }}" > AuthKey.p8
          printf "%s" "${{ secrets.P12_PASSWORD }}" > p12pass.txt

      - name: Verify P12 (hash + password)
        shell: bash
        run: |
          echo "Runner SHA256:"
          shasum -a 256 cert.p12
          echo "Verificando que la contraseña abre el p12..."
          openssl pkcs12 -in cert.p12 -nokeys -passin file:p12pass.txt -info >/dev/null

      # EXTRAER cert y key, y crear un PKCS#12 'limpio' de fallback
      - name: Extract cert & key with OpenSSL
        shell: bash
        run: |
          openssl pkcs12 -in cert.p12 -clcerts -nokeys -passin file:p12pass.txt -out dist-cert.cer
          openssl pkcs12 -in cert.p12 -nocerts -nodes -passin file:p12pass.txt -out dist-key-raw.pem
          awk '/-----BEGIN .*PRIVATE KEY-----/,/-----END .*PRIVATE KEY-----/' dist-key-raw.pem > dist-key-only.pem
          # también generamos un PKCS#12 simple por si hiciera falta
          openssl pkcs12 -export -inkey dist-key-only.pem -in dist-cert.cer -name "iOS Dist Identity" -out rebuilt.p12 -passout pass:rebuildpass
          CERT_SHA1=$(openssl x509 -in dist-cert.cer -noout -fingerprint -sha1 | sed 's/.*=//;s/://g' | tr '[:upper:]' '[:lower:]')
          echo "CERT_SHA1=$CERT_SHA1" > certsha1.env
          cat certsha1.env

      - name: Create dedicated keychain & import cert+key
        shell: bash
        env:
          KEYCHAIN_PASSWORD: actions
        run: |
          set -e
          source certsha1.env
          security create-keychain -p "$KEYCHAIN_PASSWORD" build.keychain
          security set-keychain-settings -lut 21600 build.keychain
          security default-keychain -s build.keychain
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" build.keychain

          # Importa el certificado (si ya existe, no rompas)
          security import dist-cert.cer -k build.keychain -A -T /usr/bin/codesign -T /usr/bin/security -f x509 || true

          # Importa la clave privada: prueba PEM → si falla, PKCS#12 reconstruido
          if security import dist-key-only.pem -k build.keychain -A -T /usr/bin/codesign -T /usr/bin/security -f openssl -t priv; then
            echo "Imported private key (PEM)"
          else
            echo "Fallback: import rebuilt PKCS#12"
            security import rebuilt.p12 -k build.keychain -A -T /usr/bin/codesign -T /usr/bin/security -f pkcs12 -P "rebuildpass"
          fi

          # IMPORTANTÍSIMO: añadir build.keychain a la SEARCH LIST
          security list-keychains -d user -s build.keychain
          security show-keychain-info build.keychain || true

          # Conceder acceso sin prompts a las private keys del llavero
          security set-key-partition-list -S apple-tool:,apple: -s -k "$KEYCHAIN_PASSWORD" -t private build.keychain

          echo "Identidades de codesign visibles en build.keychain:"
          security find-identity -v -p codesigning build.keychain || true
          echo "Identidades de codesign globales:"
          security find-identity -v -p codesigning || true

      - name: Install provisioning profile
        shell: bash
        run: |
          mkdir -p ~/Library/MobileDevice/Provisioning\ Profiles
          UUID=$(/usr/libexec/PlistBuddy -c 'Print :UUID' /dev/stdin <<< "$(security cms -D -i profile.mobileprovision)")
          cp profile.mobileprovision ~/Library/MobileDevice/Provisioning\ Profiles/$UUID.mobileprovision

      - name: Create ExportOptions.plist
        run: |
          cat > ExportOptions.plist <<'EOF'
          <?xml version="1.0" encoding="UTF-8"?>
          <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
          <plist version="1.0">
          <dict>
            <key>method</key><string>app-store</string>
            <key>signingStyle</key><string>manual</string>
            <key>uploadSymbols</key><true/>
            <key>stripSwiftSymbols</key><true/>
            <key>compileBitcode</key><false/>
            <key>destination</key><string>export</string>
            <key>teamID</key><string>${{ secrets.APPLE_TEAM_ID }}</string>
            <key>provisioningProfiles</key>
            <dict>
              <key>${{ secrets.APP_IDENTIFIER }}</key>
              <string>Sansebassms AppStore Profile</string>
            </dict>
          </dict>
          </plist>
          EOF

      # Plan A: build con Flutter (debería funcionar ya con la search list correcta)
      - name: Build signed IPA for App Store (Flutter)
        env:
          CI: "true"
          DEVELOPMENT_TEAM: ${{ secrets.APPLE_TEAM_ID }}
          PROVISIONING_PROFILE_SPECIFIER: Sansebassms AppStore Profile
          CODE_SIGN_STYLE: Manual
          CODE_SIGNING_ALLOWED: "YES"
        run: flutter build ipa --release --export-options-plist=ExportOptions.plist

      # Plan B (fallback): archivado y export con xcodebuild explícito
      - name: Fallback archive & export with xcodebuild (if Flutter build failed)
        if: failure()
        shell: bash
        run: |
          set -e
          cd ios
          xcodebuild -workspace Runner.xcworkspace -scheme Runner -configuration Release \
            -archivePath ../build/Runner.xcarchive \
            DEVELOPMENT_TEAM=${{ secrets.APPLE_TEAM_ID }} \
            CODE_SIGN_STYLE=Manual \
            CODE_SIGNING_ALLOWED=YES \
            PROVISIONING_PROFILE_SPECIFIER="Sansebassms AppStore Profile" \
            clean archive

          cd ..
          xcodebuild -exportArchive \
            -archivePath build/Runner.xcarchive \
            -exportOptionsPlist ExportOptions.plist \
            -exportPath build/ios/export

      - name: Upload to TestFlight (fastlane pilot)
        env:
          APP_STORE_CONNECT_KEY_ID: ${{ secrets.APP_STORE_CONNECT_KEY_ID }}
          APP_STORE_CONNECT_ISSUER_ID: ${{ secrets.APP_STORE_CONNECT_ISSUER_ID }}
        run: |
          cat > api_key.json <<EOF
          {
            "key_id": "${{ secrets.APP_STORE_CONNECT_KEY_ID }}",
            "issuer_id": "${{ secrets.APP_STORE_CONNECT_ISSUER_ID }}",
            "key": "$(cat AuthKey.p8)",
            "in_house": false
          }
          EOF
          # IPA path puede venir de Flutter o del export con xcodebuild
          IPA_PATH=$(ls build/ios/ipa/*.ipa 2>/dev/null | head -n 1 || true)
          if [ -z "$IPA_PATH" ]; then
            IPA_PATH=$(ls build/ios/export/*.ipa 2>/dev/null | head -n 1 || true)
          fi
          if [ -z "$IPA_PATH" ]; then
            echo "No se encontró el .ipa para subir." >&2
            exit 1
          fi
          fastlane pilot upload --api_key_path api_key.json --ipa "$IPA_PATH" --skip_waiting_for_build_processing true

      - name: Upload signed IPA artifact
        uses: actions/upload-artifact@v4
        with:
          name: ios-signed-ipa
          path: |
            build/ios/ipa/*.ipa
            build/ios/export/*.ipa
